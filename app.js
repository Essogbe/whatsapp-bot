const { default: makeWASocket, DisconnectReason, useMultiFileAuthState } = require('@whiskeysockets/baileys');
const { Boom } = require('@hapi/boom');
const pino = require('pino');
const axios = require('axios');
const qrcode = require('qrcode-terminal');
require('dotenv').config(); // Charger les variables d'environnement

// Configuration de l'API FastAPI
const FASTAPI_BASE_URL = 'http://localhost:8000';

class WhatsAppBot {
    constructor() {
        this.sock = null;
        this.logger = pino({ level: 'silent' });

        // Configuration des contacts autoris√©s/exclus
        this.setupContactFilters();
    }

    setupContactFilters() {
        // R√©cup√©rer les listes depuis les variables d'environnement
        const includedOnlyEnv = process.env.INCLUDED_ONLY || '';
        const excludedEnv = process.env.EXCLUDED || '';

        // Convertir en tableaux et nettoyer les num√©ros
        this.includedOnly = this.parseContactList(includedOnlyEnv);
        this.excluded = this.parseContactList(excludedEnv);

        console.log('üîß Configuration des filtres de contacts:');
        console.log(`üìû Contacts autoris√©s uniquement: ${this.includedOnly.length > 0 ? this.includedOnly.join(', ') : 'Tous autoris√©s'}`);
        console.log(`üö´ Contacts exclus: ${this.excluded.length > 0 ? this.excluded.join(', ') : 'Aucun exclu'}`);
    }

    parseContactList(contactString) {
        if (!contactString || contactString.trim() === '') {
            return [];
        }

        return contactString
            .split(',')
            .map(contact => contact.trim())
            .filter(contact => contact !== '')
            .map(contact => this.normalizePhoneNumber(contact));
    }

    normalizePhoneNumber(phoneNumber) {
        // Supprimer tous les caract√®res non num√©riques sauf le +
        let normalized = phoneNumber.replace(/[^\d+]/g, '');

        // Si le num√©ro commence par +, le garder
        if (normalized.startsWith('+')) {
            return normalized;
        }

        // Si le num√©ro commence par 00, remplacer par +
        if (normalized.startsWith('00')) {
            return '+' + normalized.substring(2);
        }

        return normalized;
    }

    extractPhoneFromJid(jid) {
        // Extraire le num√©ro de t√©l√©phone du JID WhatsApp
        // Format: num√©ro@s.whatsapp.net ou num√©ro@g.us (pour les groupes)
        const phoneNumber = jid.split('@')[0];
        return this.normalizePhoneNumber(phoneNumber);
    }

    isContactAllowed(jid, isGroup = false) {
        // Pour les groupes, on peut d√©cider d'une logique diff√©rente
        if (isGroup) {
            // Option 1: Appliquer les m√™mes r√®gles aux groupes
            // Option 2: Autoriser tous les groupes (comment√© ci-dessous)
            // return true;
        }

        const phoneNumber = this.extractPhoneFromJid(jid);

        // V√©rifier si le contact est dans la liste d'exclusion
        if (this.excluded.length > 0) {
            const isExcluded = this.excluded.some(excludedNumber =>
                phoneNumber.includes(excludedNumber) || excludedNumber.includes(phoneNumber)
            );
            if (isExcluded) {
                console.log(`üö´ Contact exclu: ${phoneNumber}`);
                return false;
            }
        }

        // Si une liste "included_only" est d√©finie, v√©rifier l'autorisation
        if (this.includedOnly.length > 0) {
            const isIncluded = this.includedOnly.some(includedNumber =>
                phoneNumber.includes(includedNumber) || includedNumber.includes(phoneNumber)
            );
            if (!isIncluded) {
                console.log(`üìµ Contact non autoris√©: ${phoneNumber}`);
                return false;
            }
        }

        console.log(`‚úÖ Contact autoris√©: ${phoneNumber}`);
        return true;
    }

    async startBot() {
        const { state, saveCreds } = await useMultiFileAuthState('auth_info_baileys');

        this.sock = makeWASocket({
            auth: state,
            logger: this.logger,
            browser: ['WhatsApp Bot', 'Brave', '1.22.71'],
            defaultQueryTimeoutMs: 60000
        });

        this.sock.ev.on('creds.update', saveCreds);
        this.sock.ev.on('connection.update', this.handleConnection.bind(this));
        this.sock.ev.on('messages.upsert', this.handleMessages.bind(this));
    }

    handleConnection(update) {
        const { connection, lastDisconnect, qr } = update;

        // Gestion du QR Code
        if (qr) {
            console.log('\nüîó QR Code g√©n√©r√© - Scannez avec WhatsApp:');
            qrcode.generate(qr, { small: true });
            console.log('\nüì± Ouvrez WhatsApp > Param√®tres > Appareils li√©s > Lier un appareil');
        }

        if (connection === 'close') {
            const shouldReconnect = (lastDisconnect?.error)?.output?.statusCode !== DisconnectReason.loggedOut;
            console.log('Connection ferm√©e, reconnexion:', shouldReconnect);
            if (shouldReconnect) {
                this.startBot();
            }
        } else if (connection === 'open') {
            console.log('‚úÖ Bot WhatsApp connect√© avec succ√®s!');
        } else if (connection === 'connecting') {
            console.log('üîÑ Connexion en cours...');
        }
    }

    async handleMessages(m) {
        const msg = m.messages[0];
        if (!msg.message || msg.key.fromMe) return;

        const messageContent = this.extractMessageContent(msg);
        const from = msg.key.remoteJid;
        const senderName = msg.pushName || 'Utilisateur';
        const isGroup = from.endsWith('@g.us');
        const participantId = msg.key.participant || msg.participant;

        console.log(`üì® Message de ${senderName} (${from}): ${messageContent}`);
        console.log(`üìç Type: ${isGroup ? 'Groupe' : 'Priv√©'}`);

        // NOUVEAU: V√©rifier si le contact est autoris√©
        const contactToCheck = isGroup ? participantId : from;
        if (!this.isContactAllowed(contactToCheck, isGroup)) {
            console.log(`üîí Message ignor√© - Contact non autoris√©`);
            return;
        }

        // Marquer le message comme lu
        await this.markAsRead(msg.key);

        // V√©rifier si le bot est tagu√© dans un groupe
        const isBotMentioned = await this.isBotMentioned(msg, isGroup);

        // Ne r√©pondre que si:
        // 1. Message priv√© OU
        // 2. Bot tagu√© dans le groupe OU
        // 3. Message commence par une commande (/)
        const shouldRespond = !isGroup || isBotMentioned || messageContent.startsWith('/');

        if (!shouldRespond) {
            console.log(`üîá Message ignor√© (groupe sans mention)`);
            return;
        }

        if (isBotMentioned) {
            console.log(`üè∑Ô∏è Bot tagu√© dans le groupe !`);
        }

        // Simuler une latence humaine de 10ms avant de r√©pondre
        await this.sleep(10);

        // Traitement du message via FastAPI
        try {
            // Afficher l'indicateur "en train d'√©crire"
            await this.sendTyping(from);

            const response = await this.processMessageWithAI(
                messageContent,
                from,
                senderName,
                isGroup,
                isBotMentioned,
                participantId
            );

            // Dans un groupe, mentionner l'utilisateur dans la r√©ponse
            if (isGroup && participantId) {
                await this.sendMessageWithMention(from, response, participantId, senderName, msg);
            } else {
                await this.sendMessage(from, response);
            }
        } catch (error) {
            console.error('‚ùå Erreur lors du traitement:', error);
            await this.sendMessage(from, "D√©sol√©, je rencontre un probl√®me technique. R√©essayez plus tard.");
        }
    }

    extractMessageContent(msg) {
        if (msg.message.conversation) {
            return msg.message.conversation;
        } else if (msg.message.extendedTextMessage) {
            return msg.message.extendedTextMessage.text;
        }
        return '';
    }

    async isBotMentioned(msg, isGroup) {
        if (!isGroup) return false;

        try {
            // R√©cup√©rer l'ID du bot
            const botId = this.sock.user.id;
            const botNumber = botId.split(':')[0];

            // V√©rifier les mentions dans le message
            const messageContent = this.extractMessageContent(msg);
            const mentions = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];

            // V√©rifier si le bot est dans les mentions
            const isMentioned = mentions.some(mention =>
                mention.includes(botNumber) || mention.includes(botId)
            );

            // // V√©rifier aussi par le texte (au cas o√π)
            // const isTextMention = messageContent.includes(`@${botNumber}`) ||
            //                     messageContent.includes('@bot') ||
            //                     messageContent.includes('@chatbot') ||
            //                     messageContent.includes("@47700225572929");

            return isMentioned || isTextMention;
        } catch (error) {
            console.error('‚ùå Erreur v√©rification mention:', error);
            return false;
        }
    }

    async processMessageWithAI(message, userId, userName, isGroup = false, isMentioned = false, participantId = null) {
        try {
            const response = await axios.post(`${FASTAPI_BASE_URL}/chat`, {
                message: message,
                user_id: userId,
                user_name: userName,
                is_group: isGroup,
                is_mentioned: isMentioned,
                participant_id: participantId
            }, {
                headers: {
                    'Content-Type': 'application/json'
                },
                timeout: 100000 // 100 secondes
            });

            // Simuler un d√©lai de r√©flexion r√©aliste (entre 500ms et 2s)
            const thinkingTime = Math.random() * 1500 + 500;
            await this.sleep(thinkingTime);

            return response.data.response;
        } catch (error) {
            console.error('Erreur API FastAPI:', error.message);
            throw error;
        }
    }

    async sendMessage(to, message) {
        try {
            await this.sock.sendMessage(to, { text: message });
            console.log(`üì§ Message envoy√© √† ${to}: ${message}`);
        } catch (error) {
            console.error('‚ùå Erreur envoi message:', error);
        }
    }

    async sendMessageWithMention(to, message, mentionJid, mentionName, quotedMessage) {
        try {
            // Ajoute le tag visuel @num√©ro dans le message
            const tag = `@${mentionJid.split('@')[0]}`;
            const fullMessage = `${tag} ${message}`;

            await this.sock.sendMessage(to, {
                text: fullMessage,
                mentions: [mentionJid]
            }, {
                quoted: quotedMessage
            });

            console.log(`üì§ Message avec mention envoy√© √† ${to}: ${fullMessage}`);
        } catch (error) {
            console.error('‚ùå Erreur envoi message avec mention:', error);
            // Fallback sans mention (avec le nom affich√© en clair)
            await this.sendMessage(to, `${mentionName}: ${message}`);
        }
    }

    async getGroupInfo(groupId) {
        try {
            const groupMetadata = await this.sock.groupMetadata(groupId);
            return {
                name: groupMetadata.subject,
                participants: groupMetadata.participants.length,
                admins: groupMetadata.participants.filter(p => p.admin).length
            };
        } catch (error) {
            console.error('‚ùå Erreur r√©cup√©ration info groupe:', error);
            return null;
        }
    }

    // M√©thodes utilitaires
    async markAsRead(messageKey) {
        try {
            await this.sock.readMessages([messageKey]);
            console.log(`‚úÖ Message marqu√© comme lu`);
        } catch (error) {
            console.error('‚ùå Erreur marquage message lu:', error);
        }
    }

    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async sendTyping(to, duration = 2000) {
        try {
            await this.sock.sendPresenceUpdate('composing', to);
            // Arr√™ter l'indicateur apr√®s la dur√©e sp√©cifi√©e
            setTimeout(async () => {
                await this.sock.sendPresenceUpdate('paused', to);
            }, duration);
        } catch (error) {
            console.error('‚ùå Erreur indicateur frappe:', error);
        }
    }

    async sendImage(to, imagePath, caption = '') {
        try {
            await this.sock.sendMessage(to, {
                image: { url: imagePath },
                caption: caption
            });
        } catch (error) {
            console.error('‚ùå Erreur envoi image:', error);
        }
    }

    async sendDocument(to, documentPath, fileName) {
        try {
            await this.sock.sendMessage(to, {
                document: { url: documentPath },
                fileName: fileName,
                mimetype: 'application/pdf'
            });
        } catch (error) {
            console.error('‚ùå Erreur envoi document:', error);
        }
    }
}

// D√©marrage du bot
const bot = new WhatsAppBot();
bot.startBot().catch(console.error);

// Gestion gracieuse de l'arr√™t
process.on('SIGINT', () => {
    console.log('\nüõë Arr√™t du bot...');
    process.exit(0);
});

module.exports = WhatsAppBot;